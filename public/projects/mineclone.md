---
name: Minecraft Clone
images: 
    - /assets/images/project/mineclone/mineclone.png
description: A clone of the game Minecraft, which I made for my high school computer science 30 final project.
links:
    source: https://github.com/Kappabyte/MinecraftClone
tags:
    - opengl
    - gamedev
    - java
---

This is my Computer Science 30 final project from my grade 11 year. It was written
completely on my own, using lwjgl as OpenGL bindings as the class required java
to be used for the project.

# In-Class Video Presentation
<iframe width="790" height="444" src="https://www.youtube.com/embed/8hmXpr0RXs4?modestbranding=1&showinfo=0" title="CS30 Final Project - Mineclone" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

# Technology & Motivation
The underlying game engine I created prior to the final project. I was interested in learning
OpenGL and graphics technology in general, so I decided to create a (relatively simple) 3D game
engine. I based the engine structure (and public API) around other similar engines (like Unity).
It uses an entity-component based structure, where a scene is built up of GameObjects, which in turn
have components (logic), and other GameObjects as children.

# Code Snippits & Explanation 
In this next section, I will explain some of the code from the project, as well as give insight
as to the structure of the engine

## Initializing the engine
To initialize the application, you can do the following:

```java
public final class App extends Application {

    public static void main(String[] args) {
        Log.setLogLevel(LogLevel.DEBUG);
        KappaEngine.init(new App());
    }

    @Override
    public void onStart() {
        Window window = new AppWindow("Mineclone");
        WindowManager.registerWindow(window);
    }

    @Override
    public void onUpdate() {
    }
}
```

Extending the application class allows you to create a new Application using KappaEngine. Once everything is initialized, 
the `onStart()` method is called, where the window is created and added to the window manager.

## Creating the Scene
Once our window is ready, we can create the scene as follows:

```java
@Override
protected void onWindowReady() {
    game = new Scene();
    setScene(game);

    GameObject world = new GameObject("World");
    World worldComponent = new World();
    world.addComponent(worldComponent);
    for(int x = 0; x < 5; x++) {
        for(int y = 0; y < 5; y++) {
            worldComponent.spawnChunk(x, y);
        }
    }
    game.addGameObject(world);

    GameObject player = new GameObject("Player");
    GameObject camera = new GameObject("Camera");
    player.addChild(camera);
    camera.addComponent(new Camera(this));
    player.addComponent(new Rigidbody(1.0f));
    player.addComponent(new CharacterController(camera));
    getScene().addGameObject(player);
    player.getTransform().setPosition(new Vector3f(5, 40, 5));
    camera.getTransform().setPosition(new Vector3f(0, 1.6f, 0));
    getScene().setActiveCamera(camera.GetComponent(Camera.class));
}
```

Here, `world` and `player` are game objects in the scene. `world` is assigned the `World` component, which is responsible for rendering and
interactions with the game world. The `player` gameobject is also set up here.

## Terrain Generation
Here, I made use of [fastnoise](https://github.com/Auburn/FastNoise_Java) to generate the base terrain shape as follows for each chunk:
```java
Chunk chunk = new Chunk();
chunks.put(chunkCoordinate, chunk);

for(int x1 = 0; x1 < 16; x1++) {
    for(int z1 = 0; z1 < 16; z1++) {
        float height = (noise.GetNoise(x * 16 + x1, y * 16 + z1) + 1.0f) / 2.0f;
        for(int y1 = 0; y1 < height * 40; y1++) {
            BlockMaterial material;
            if(y1 < height * 40 && y1 > height * 40 - 4) {
                material = BlockMaterial.DIRT;
            } else {
                material = BlockMaterial.STONE;
            }
            chunk.setBlockAt(x1, y1, z1, new Block(new Vector3i(x1, y1, z1), material));
        }
        chunk.setBlockAt(x1, (int) (height * 40), z1, new Block(new Vector3i(x1, (int) (height * 40), z1), BlockMaterial.GRASS_BLOCK));
    }
}

...
```

and trees can be generated by
```java showLineNumbers{20}
...

long chunkSeed = (x + x * y) * seed;
Random chunkRandom = new Random(chunkSeed);
int numberOfTrees = chunkRandom.nextInt(10) + 3;
for(int i = 0; i < numberOfTrees; i++) {
    int tx = chunkRandom.nextInt(16);
    int tz = chunkRandom.nextInt(16);
    int ty = chunk.getMaxYAtBlock(tx, tz);

    BlockMaterial log = BlockMaterial.OAK_LOG;
    BlockMaterial leaves = BlockMaterial.OAK_LEAVES;
    if(chunkRandom.nextBoolean()) {
        log = BlockMaterial.BIRCH_LOG;
        leaves = BlockMaterial.BIRCH_LEAVES;
    }

    setBlockAt(x * 16 + tx, ty + 1, y * 16 + tz, log);
    setBlockAt(x * 16 + tx, ty + 2, y * 16 + tz, log);
    setBlockAt(x * 16 + tx, ty + 3, y * 16 + tz, log);
    for(int x1 = -2; x1 < 3; x1++) {
        for(int z1 = -2; z1 < 3; z1++) {
            setBlockAt(x * 16 + tx + x1, ty + 4, y * 16 + tz + z1, leaves);
            setBlockAt(x * 16 + tx + x1, ty + 5, y * 16 + tz + z1, leaves);
            if(x1 > -2 && x1 < 3 && z1 > -2 && z1 < 3) {
                setBlockAt(x * 16 + tx + x1, ty + 6, y * 16 + tz + z1, leaves);
            }
        }
    }
    setBlockAt(x * 16 + tx, ty + 4, y * 16 + tz, log);
    setBlockAt(x * 16 + tx, ty + 5, y * 16 + tz, log);
    setBlockAt(x * 16 + tx, ty + 6, y * 16 + tz, log);
    setBlockAt(x * 16 + tx, ty + 7, y * 16 + tz - 1, leaves);
    setBlockAt(x * 16 + tx - 1, ty + 7, y * 16 + tz, leaves);
    setBlockAt(x * 16 + tx, ty + 7, y * 16 + tz + 1, leaves);
    setBlockAt(x * 16 + tx + 1, ty + 7, y * 16 + tz, leaves);
    setBlockAt(x * 16 + tx, ty + 7, y * 16 + tz, leaves);
}
```

## Rendering Chunks
To avoid rendering faces that are not visible, I conditionally added faces to the chunk mesh as follows:
```java
for(int x = 0; x < blocks.length; x++) {
    for(int y = 0; y < blocks[x].length; y++) {
        for(int z = 0; z < blocks[x][y].length; z++) {
            if(blocks[x][y][z] == null) continue;

            if((x > 0 && blocks[x-1][y][z] == null) || (x == 0 && (west == null || west.blocks[15][y][z] == null))) {
                addBlockFace(blocks[x][y][z], x,y,z, BlockFace.WEST, verticies, indicies, uvs, normals);
            }
            if((z < blocks[x][y].length - 1 && blocks[x][y][z + 1] == null) || (z == blocks[x][y].length - 1 && (north == null || north.blocks[x][y][0] == null))) {
                addBlockFace(blocks[x][y][z], x,y,z, BlockFace.NORTH, verticies, indicies, uvs, normals);
            }
            if((x < blocks.length - 1 && blocks[x + 1][y][z] == null) || (x == blocks.length - 1 && (east == null || east.blocks[0][y][z] == null))) {
                addBlockFace(blocks[x][y][z], x,y,z, BlockFace.EAST, verticies, indicies, uvs, normals);
            }
            if((z > 0 && blocks[x][y][z - 1] == null) || (z == 0 && (south == null || south.blocks[x][y][15] == null))) {
                addBlockFace(blocks[x][y][z], x,y,z, BlockFace.SOUTH, verticies, indicies, uvs, normals);
            }
            if((y < blocks[x].length - 1 && blocks[x][y + 1][z] == null) || y == blocks[x].length - 1) {
                addBlockFace(blocks[x][y][z], x,y,z, BlockFace.TOP, verticies, indicies, uvs, normals);
            }
            if((y > 0 && blocks[x][y - 1][z] == null) || y == 0) {
                addBlockFace(blocks[x][y][z], x,y,z, BlockFace.BOTTOM, verticies, indicies, uvs, normals);
            }
        }
    }
}
```

In essence, if a block is **not** adjacent to the current block in any particular direction, either in the current chunk or 
a bordering chunk, then the face will be added.
